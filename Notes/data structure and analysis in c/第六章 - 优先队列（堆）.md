# 第六章 - 优先队列（堆）

## 1.二叉堆

### 1.1性质

- 堆是一个完全二叉树（被填满的二叉树，除了底层）
  - 可使用简单的数组来实现堆
- 堆序性 
  - 父节点的关键子小于该节点的关键字（根节点除外）
  - 最小元总是可以在根处找到



### 1.2堆操作

#### 插入

- 上滤
  - 在下一个位置（保持完全二叉树的形态）创建空穴
  - 若该值比其父节点小，则交换，反复进行。
- 在位置0处放置一个很小的值(sentinel)，该值必须小于等于待插入的任何值----哑信息
  - 避免了每次循环都要进行的测试，节省了一些时间

```c
void Insert(ElemtType X,PriorityQueue H){
    int i;
    
    if(isFull(H)){
        Error("full");
        return;
    }
    //在完全二叉树的末尾创建空穴
    //不断上移直到父节点不再小于X
    //i最小是1，就会跳出循环。因为Elements[1/2 (=0)]元素存放的是最小元素，X一定大于该元素，故不会死循环
    for(i = ++H->Size;H->Elements[i/2] > X;i /= 2){
        H->Elements[i] = H->Elements[i/2];
    }
    H->Elements[i] = X;
}
```

#### 删除最小元

- 下滤
- 结点不总有两个儿子
  - 添加测试语句
  - *假设每个结点都有两个儿子，将大于堆中任何值的一个关键字加入到单儿子结点的右儿子上。

```c
ElementType DeleteMin(PriorityQueue H){
    int i , Child;
    ElementType MinElement,LastElement;
    
    if(isEmpty(H)){
        Error("empty");
        return H->Elements[0];
    }
    
    MinElement = H->Elements[1];
    LastElement = H->Elements[H->Size--];
    
    for(i = 1; i*2 <= H->Size;i = Child){
        Child = i*2;
        
        if(Child != H->Size && H->Elements[Child +1] < H->Elements[Child])
            Child++;
        
        if(LastElement > H->Elements[Child])
            H->Elements[i] = H->Elemnets[Child];
        else
            break;
    }
    H->Elements[i] = LastElement;
    return MinElement;
}
```

