#  LOG - DIY X86 Operating System in C

## LOG 24.3.4

编写引导程序

1. 完成段寄存器初始化，都设置为0
2. 设置好boost程序的栈顶指针
3. 能使用BIOS中的方法进行输出字符
4. 在boost中利用BIOS读取磁盘第二个扇区开始的64字节（在此处放置loader、未完成）

### 一、引导程序：接管控制权



计算机启动流程

1. 16位实模式（兼容以前的程序） 
2. 跳转到BIOS（基本输入输出系统） （硬件自检）
3. 运行引导代码
4. 进入操作系统

接管运行控制

![image-20240304192558647](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20240304192558647.png)



引导程序（boot）做什么?

1. 硬件检测
2. 进入保护模式
3. 加载操作系统



boot程序在第零个扇区，512字节，能做的事情有限：

​	boot --> loader --> 更加复杂的初始化工作	





实模式：

- 16位代码
- 1MB以内的内存



BIOS:

​	许多函数、寄存器传递参数

​	软中断显示字符

​	读取磁盘，loader





------



## LOG 24.3.5

引导程序：

1. 代码从boot汇编到boot.c到loader汇编到loader_16.c

loader：

1. 创建loader工程
2. 利用内联汇编在loader_16.c内输出字符串
3. 检查内存，并打印相关信息
4. 进入保护模式：
   1. 在头文件中写内联函数，封装汇编代码
   2. 禁止中断
   3. 打开A20
   4. 设置gdt
   5. 设置cr0位



进入c语言环境并跳转到loader

boot汇编 --> boot.c --> loader汇编 --> loader.c(16位)

1. 汇编到c
   1. jmp指令跳转到xxx_entry（c函数）
2. 创建loader工程
   1. start.S loader的启动位置
   2. loader.h 头文件
   3. loader_16.h 计算机先进入实模式，故loader函数有一部分以16位代码模式运行
   4. loader_32.h loader负责将计算机从实模式转换为保护模式，故有32位代码，且该部分为主要的loader代码
   5. 配置cmake文件
      1. 顶层cmakelist ：add_subdirectory(./source/loader)
      2. loader内的cmakelist
3. 程序间跳转（boot工程跳转到loader工程）
   1. 不同工程，boot不知道loader中的start函数
      1. 调整gdb参数
      2. 指定地址为函数





### 二、 加载器loader的实现



利用内联汇编显示字符串（检查异常）/c语言

​		\__volatile__ 表示该内联汇编禁止编译器优化 



检查可用内存容量

​		其中一种



从实模式切换到保护模式

- 实模式
  - 1mb内存
  - 内核寄存器最大16位宽，操作数最大16位宽
  - 没有保护机制，不安全
  - 可以使用BIOS的服务接口，保护模式下不可用
- 保护模式
  - 32位
  - 4GB
  - 4种特权级
  - 虚拟内存，分页机制



![image-20240305201446058](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20240305201446058.png)





内联函数：

- 生成指令少时可以
- 直接将代码插入到指定位置
- 速度快，没有函数的调用，保存，恢复和返回。
- 加上static 
- 封装汇编代码










------

## LOG 24.3.6



loader：

1. 进入保护模式

   1. 进行远跳转跳转到32位代码中（汇编）
   2. 汇编代码中设置各段寄存器，都调整为32位
   3. 跳转到c代码中loader_kernel()

2. 加载kernel

   1. 读取磁盘 --- 从第100个开始，读取500个
      1. 将系统内核加载代码写入磁盘
      2. 注意磁盘信息是否**正确完整**读入内存
   2. 跳转到系统内核加载代码（汇编）
   3. 初始化kernel（c）

3. 将loader中的启动信息（c函数中得到的）传递给kernel内的初始化函数（c函数）

   1. 更改2.b中的代码

      1. 跳转代码相当于函数调用
      2. 将loader得到的boot_info作为函数参数传递给kernel/init内的汇编代码

   2. 将传递给汇编代码的参数传递给c代码（利用栈）

      1. 模仿c语言函数调用的反汇编结果，先将参数保存到寄存器中（eax）

      ```assembly
      push %ebp
          mov %esp,%ebp
          mov 0x8(%ebp),%eax
          #偏移量设置为8是因为此时ebp指向的条目，上一条保存该函数的返回地址，再上一条为参数
      ```

      1. 将eax得到的boot_info压入栈，作为参数传递给下一个call的函数（c函数）

   3. c函数接收到boot_info信息



使用LBA模式读取磁盘

​			跳转到内核

向内核传递启动信息（loader(boot_info)-->kernel）

​	通过函数传参的方式（栈），从loader向kernel传递boot_info 结构体





------

## LOG 24.3.7

loader：

1. 原本的kernel文件为二进制文件
   1. 不能很好的利用硬件接口
   2. 将kernel转换成elf文件
   3. 更改代码：
      1. 把磁盘中的kernel代码读取到0x100000内存后：
      2. 利用reload_elf函数，将elf中的代码拷贝到0x10000的代码处，但是这个地址并不精准，故使用e_entry接口来表示kernel可执行代码的入口
      3. 仍利用昨天方法，含参函数，跳转到kernel入口c函数，并传递信息



kernel ：

-cpu：

1. 重新加载GDT(global descriptor table)
   1. 设置GDT，（初始化gdt）
      1. 设置段描述符设置函数：能够设置GDT表的各记录的属性
      2. 初始化所有gdt表属性
      3. 设置cs段和ds段gdt记录
      4. 加载gdt到gdtr寄存器
      5. 重置各段寄存器与栈位置





链接脚本：

| text | rodata       | data                 |         bss          |
| ---- | ------------ | -------------------- | :------------------: |
| 代码 | 常量及字符串 | 全局或静态的初始化过 | 未初始化的全局或静态 |

### 三、 中断与异常处理



GDT表：

x86 : 分段存储 + 分页存储

global descriptor table 分段存储 在内存中存放的结构体数组





------

​	

## LOG 24.3.8

kernel-cpu

1.  设置IDT函数并初始化IDT表
    1. bug：中断时无法跳转到指定的汇编函数
       1. 当前IDT表设置正确，加载正确
       2. ？？是否是GDT加载出错？？GDT表，对照视频未出错
       3. 是否是kernel映像文件加载出错？
2.  除零捕获失败



设置IDT表



------





## LOG 24.3.11

除零异常捕获成功：问题在cpu.h文件中（反正是头文件，忘了哪个了





------

## LOG 24.3.13

1. 解析异常栈信息

2. 处理各种异常

3. 成功设置定时器中断处理程序，能够定时进行中断并且能告诉cpu中断处理程序结束



解析异常栈信息：

​	中断压栈：硬件压入/pusha/push/call

​	作为参数传递给c函数

​	参数太多？---》结构体指针



利用宏重用异常处理代码



处理其它类型的异常:

​	填充idt表项



初始化中断控制器

​	异常/中断

​	早期中断处理芯片

​	跟硬件关系密切



终端的打开和关闭

​	





------

## LOG 24.3.18

1. 初始化硬件：日志输出
2. 实现基本的信息输出（非格式化）
3. 若干字符串和内存操作函数（只有定义，未具体实现）

### 四、 日志与printf格式化输出

前面更多的与硬件打交道

此部分用于：打印信息，方便调试

c lib 中的 printf  调用windows或linux的接口进行打印输出，但是在自己开发的操作系统上没有相应的工具链，故要实现一个自己的printf

​			

------

## LOG 24.3.19

​	日志：

1. 实现字符串和内存操作的函数
2. 实现字符串的格式化（支持将字符串，十进制，十六进制和字符加入字符串中）
3. 在异常处理函数中打印异常栈信息
4. 实现宏ASSERT，用于调试

进程：

1. 创建两个小任务
2. 添加任务状态段结构体
3. “任务”的简单初始化
4. 设置gdt表项的tss描述符，设置tr寄存器实现简单的任务跳转（利用硬件）
5. 另一种切换方法（软件，更简单高效功能少）



### 五、 实现简单的进程切换

操作系统根据 intel提供的任务切换模块 进行进程并行

添加任务状态段（task state segment）

{

任务的链接，不同特权级的代码段和栈指针，页表（虚拟内存相关），寄存器信息

}



进程并行：

cpu需要处理：保存状态，切换状态，恢复状态

任务运行状态保存到tss里面





任务切换1：

intel 硬件 任务切换

tss 选择子

jmp tss_selector:

​	硬件自动保存和恢复tss中的寄存器信息



另一种切换机制：

​			更高效更简单

​			手动保存，手动恢复

​			不进行权限的检查

​			平坦模型不需要保存段寄存器

​			保存通用寄存器（一部分），运行状态

​			利用未使用的栈空间（当前进程的）来临时保存寄存器信息，保存一部分



------



## LOG 24.3.22

链表：

1. 定义链表节点和链表类型，并完成初始化函数
2. 实现查询函数
3. 链表的插入、删除
4. 通过宏定义得到node所在结构体的指针

进程管理：

1. 初始化任务管理器（结构体）
1. 更改初始化任务函数，将任务加入到就绪队列中
1. 在进程中实现该进程放弃cpu
1. 实现当进程超时时自动放弃cpu
1. 保护临界资源（串口，全局变量等），防止发生错误

### 六、 实现链表数据结构

进程不止简单的两个，对进程进行统一的管理（队列）

实现双向队列，方便插入和删除



将node插入队列而不是task结构体：更高的通用性



利用node的地址能够得到node所在结构体的地址：

- 宏定义
- 结构体地址为node地址 减 偏移量
- 偏移量
  - 假设结构体地址为零
  - node地址就是结构体地址



### 七、 进程的管理与延时

当前的缺陷：

只支持两个任务/需要进程自己切换/不支持延时操作

任务管理器 - task manager

- 延时队列
- 就绪队列
- 进程队列--创建好的所有进程



当前问题：

进程决定将cpu传递给哪个进程继续执行

​	-- 进程只主动的释放cpu，不需决定后续哪个进程继续占用cpu

​	------ 进程从就绪队列的头部移动到尾部即可



​	--进程自动放弃cpu：

 	------进程按照时间片运行



当前问题：

在任务切换时，不同任务的输出出现资源冲突

- 并发：交替 -- 单核
- 并行：重叠 -- 多核
- 临界资源/临界区

解决问题：保证信息输出完整，在运行到临界区不能被打断

​		------关中断

​		---------如果保护区代码运行时间长，简单的关中断会导致性能降低，后面会采用互斥信号量的方法进行迭代改进



让进程能够延迟进行：

任务管理器增加一个队列：延时队列

将进程从就绪队列移出，进入延时队列，利用定时中断，决定是否将进程移回，插入到就绪队列的尾部



------



## LOG 24.3.26

1. 实现进程延时函数
2. 解决多进程调用延时函数会出现保护异常的问题
3. 设置计数信号量并初始化
4. 设置发信号和等信号函数
5. 使用互斥锁优化临界资源保护



实现sys_sleep函数

当前问题：

只能在一个进程中运行sleep函数，当多个运行的进程都调用sleep函数时，会出现保护异常

解决问题：

创建空闲进程，平时不运行，只有当cpu空闲时（其他进程都放弃cpu）才会运行

注意：空闲进程不在readylist中！



### 八、 进程间的同步与互斥

计数信号量：

![image-20240326110025955](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20240326110025955.png)



等信号：

![image-20240326110142448](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20240326110142448.png)



发信号：

![image-20240326120731550](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20240326120731550.png)



互斥锁

临界资源保护 --- 关中断：可能占用cpu太长时间

​				互斥锁！

​				申请锁 ---等待--- 拿到锁 --- 释放锁



上锁：

![image-20240326205639371](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20240326205639371.png)

解锁:

![image-20240326210450452](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20240326210450452.png)



### 九、虚拟内存管理和保护模式

内存管理问题：

![image-20240326215004205](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20240326215004205.png)



多进程的内存分配：

![image-20240326215539889](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20240326215539889.png)

![image-20240326215937453](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20240326215937453.png)



------



## LOG 24.3.27

1. 实现位图结构并实现初始化函数
2. 实现对位图中位的分配的操作函数
3. 创建地址分配结构管理位图
4. 实现内存初始化：
   1. 规划内存1mb以下为操作系统，以上为各进程
   2. 为进程内存设置内存分配器，并将内存分配器的位图缓存放置在kernel（.bss）的后面





管理内存页的简单的方法：

将内存页做成链表

其他方法：

位图：给每个页分配一个位 ---> 一个大数组

​			内存的分配和回收：置零或置一



定义一个地址分配器，管理位图

内存规划：

![image-20240327212758902](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20240327212758902.png)

​	





------

## LOG 24.3.28

1. 设置cr0,cr3,cr4寄存器以到开分页机制
2. 设置页表第零项，使之做等值映射
3. 实现一部分创建内核页表函数-建立映射表



进程认为：一段连续的存储空间 -- 线性地址 / 逻辑地址 （平坦流模型）

内存上：可能由不连续的内存页组成 --- 物理地址



开启分页机制：

分页机制：提供一个地址转换表

​	转换表：一个地址到另一个地址的转换关系---->页与页之间的映射

intel：两级转换表---节省空间但复杂

​			一级页表：高10位---页目录

​								低22位---偏移量



cr3寄存器 指向页表目录

cr4 设置单级页表

cr0开启分页机制



更复杂的二级页表：

对内存进行简单的保护 ： 读写权限的设置

​		一级表项的控制位 控制二级表指向的所有的物理页

​		二级表项的控制位 控制其指向的物理页的读写



------



## LOG 24.3.30

1. 创建页目录和页表结构

2. 建立映射表

   



## LOG 24.3.31

1. 创建内核页表 - 添加权限处理
2. 为进程创建页表





问题：

在时间断点后分配任务，远跳转到指定任务时发生错误

1. 进程的TSS结构中需要一个cr3
2. cpu从tss.cr3 加载到cr3寄存器 里面
3. 进程有自己的页表



![image-20240331145106917](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20240331145106917.png)



1. 进程相互隔离
2. 进程间能共享操作系统的代码和数据

 

------



## LOG 24.4.1

1. 隔离操作系统与进程 - 代码分离





### 十、 隔离操作系统与进程



现有问题：进程跟操作系统混在一起

​	分离：将进程搬到高地址处

1. 建立进程的运行空间
2. 代码拷贝
3. 从操作系统跳转

------



## LOG 24.4.7

1. 修改lds脚本文件，隔离操作系统与进程
2. 实现代码搬运函数，为当前进程分配内存页并建立映射关系





隔离操作系统与进程-地址分离

修改连接脚本文件

- .xxx 0x000 设置起始地址（虚拟）
- 无AT，物理等于虚拟
- 有AT，AT设置物理地址

隔离操作系统与进程-代码搬运

1. 起始地址结束地址
2. 分配内存
3. 代码搬运

------

## LOG 24.4.8

1. 调整应用特权级，在task_manager结构体内添加代码段和数据段的选择子，将其改为特权级3
2. 调整异常处理函数do_handler_page_fault和do_handler_general_protection，使之输出更多的信息
3. 在任务初始化时修改空闲任务的特权级为0
4. first_task进程特权级调整到3



调整应用的特权级

- ​	将内存划分为四个特权级
- ​	level0内核进程/level3应用程序
- ​	CPL - 代码的特权级
- ​	RPL - 以什么身份访问内存
- ​	DPL - 这块内存最低以什么权限才能访问
- ​	访问栈空间：CPL = RPL = DPL才能访问
- ​	非一致性代码段：CPL = DPL



简化特权级：

- 平坦模型：段寄存器指向同一块内存，特权级设置不管用
- 利用分页机制解决此问题，页内的U/S位决定该内存允许操作系统/应用程序访问

![image-20240408190953434](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20240408190953434.png)

![image-20240408191046174](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20240408191046174.png)



现在存在的问题：

应该特权级3的first_task特权级为0

应该特权级0的idle_task特权级为3

应该换过来



调整异常处理程序

异常处理函数为特权级0，一般函数为特权级3

权限变化，栈变化

将之前用到的栈（level3）压入新的栈空间（level0），供异常处理程序使用 -- **安全**  



权限的切换

在first_task运行之前，将特权级0切换为特权级3

iret指令：将栈中的内容依次弹出到寄存器然后返回到特权级3

​					手动压入类似中断时的寄存器值

问题：first_task_main进入c函数后，会进行压栈操作，但是此时的esp指向0，故进入函数后cpu重启

------

## LOG 24.4.10

1. 为进程添加特权级0和特权级3的栈空间
2. 为gdt表现添加调用门
3. 实现系统调用的调用和返回函数
4. 实现msleep系统调用





解决前天的问题：分配两个栈空间，一用于特权级零处理异常系统调用处理中断，一个用于特权级三正常使用

现在进入c函数能够压栈

现在问题：first_task不能使用log_printf() -- 抛出page fault异常（特权级三不能访问特权级0的函数） ---- 证明了分页能够形成保护

解决办法：

提供系统调用接口

特权级切换：

1. 中断/异常  3 -- > 0
2. 进入第一个进程进行执行 0 -- > 3
3. 门描述符：
   1. 中断门  -- 1
   2. 任务门
   3. 调用门：实现系统调用





![image-20240410213103712](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20240410213103712.png)

------





## LOG 24.4.12

1. getpid()函数的实现
1. print_msg()





fork：

​	创建更多的进程 -- 生成一个自己的克隆体

​	父子进程公用同一段代码，子进程从fork之后开始运行





















​	





